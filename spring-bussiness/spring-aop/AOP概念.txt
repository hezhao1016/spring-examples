AOP -> 我们要在一些方法执行前/执行后/抛出异常时进行一些额外的操作。

为了完成这件事情，需要告诉程序：
1.What? 哪些方法需要进行额外的操作。
2.How? 什么时候进行额外操作？额外操作要做什么？

AOP有一堆令人晦涩的术语，下面按照以上两步来进行解释：
第一步：
我们通过定义一个表达式(Pointcut)来告诉程序，我们需要对那些方法增加额外的操作。
通过这个表达式(Pointcut)，我们得到了那些需要增强的方法(Joinpoint)。
第二步：
我们需要告诉程序：这些方法(Joinpoint)需要做怎样的增强(Advice)：
1.什么时候进行额外操作？(执行前/执行后/抛出异常时)。
2.额外操作要做什么？


我们把两个步骤定义到一个地方(Aspect).
这两个步骤涉及到的被修改对象我们叫做(Target Object).
完成以上操作的动作我们叫做(Weaving)

下面总结一下：

需要我们关心的：
Pointcut: 一个表达式，用来找出需要被增强的方法。
Advice: 这个方法要如何被增强。

概念性的：
Joinpoint: 通过Pointcut找出来的结果。
Aspect: 整个AOP规则的定义。
Target Object: 被修改了的Objects。
Weaving: 执行AOP的过程。


-------------------

Aspect Oriented Programming 面向切面编程（面向方面编程）。

 从传统面向对象的编程角度出发，相对于OOP，面向AOP更具有可拓展性和高维护性的优势。具体表现在：以往我们都以“世界万物皆对象”的思想进行编程时，会将一切事物抽象成一个实体，并使用这个实体进行我们业务方面的拓展。当然，这样做是不错的，但是带来了问题！比如说，当我们抽象出来的一个实体不再是一个具体的实物，而是可分为多个抽象实物的统一点时，那么之前对于该实体进行的一切程序开发都需要进行维护和拓展，从而增加了维护成本。

 而AOPer崇尚面向方面编程，即将一切实物都抽象的看做是多个实体的抽象体，而每个不同类型的抽象体都能够作为这个实物的一种实现机制的表现，从而在业务拓展时减少对原有代码的维护，取而代之的则是 增加->切换 的操作。

 -------------

IOC，名为对象控制反转，简单的可以理解为AOP概念的一个功能实现。主要运用在对象中！

 当你将面向对象理解的比较深入的时候，就可以这样理解IOC了：

当你需要敲碎一块石头时，你将怎么做，分别说明这个过程？

 我可以给你的答案是：

1、我可以用槌子来敲碎石头

2、我可以用碎石机来敲碎石头

3、我可以找别人来帮忙敲碎石头

 然后分析这个需求。主体是“我”，动作是“敲”。这里的IOC主要是用来控制“用什么”的，从而为了达到目的而使用不同的方法。


---------------------

1.我所知道的aop

　　初看aop,上来就是一大堆术语，而且还有个拉风的名字，面向切面编程，都说是OOP的一种有益补充等等。一下子让你不知所措，心想着：怪不得很多人都和我说aop多难多难。当我看进去以后，我才发现：它就是一些java基础上的朴实无华的应用，包括ioc，包括许许多多这样的名词，都是万变不离其宗而已。

　　2.为什么用aop

　　1就是为了方便，看一个国外很有名的大师说，编程的人都是“懒人”，因为他把自己做的事情都让程序做了。用了aop能让你少写很多代码，这点就够充分了吧

　　2就是为了更清晰的逻辑，可以让你的业务逻辑去关注自己本身的业务，而不去想一些其他的事情，这些其他的事情包括：安全，事物，日志等。

　　3.那些aop的术语

　　初看这么多术语，一下子都不好接受，慢慢来，很快就会搞懂。

　　1.通知（Advice）

　　就是你想要的功能，也就是上面说的 安全，事物，日志等。你给先定义好把，然后在想用的地方用一下。

　　2.连接点（JoinPoint）

　　这个更好解释了，就是spring允许你使用通知的地方，那可真就多了，基本每个方法的前，后（两者都有也行），或抛出异常时都可以是连接点，spring只支持方法连接点.其他如aspectJ还可以让你在构造器或属性注入时都行，不过那不是咱关注的，只要记住，和方法有关的前前后后（抛出异常），都是连接点。

　　3.切入点（Pointcut）

　　上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有几十个连接点了对把，但是你并不想在所有方法附近都使用通知（使用叫织入，以后再说），你只想让其中的几个，在调用这几个方法之前，之后或者抛出异常时干点什么，那么就用切点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。

　　4.切面（Aspect）

　　切面是通知和切入点的结合。现在发现了吧，没连接点什么事情，连接点就是为了让你好理解切点，搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的before,after，around等就能知道），而切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。

　　5.引入（introduction）

　　允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗

　　6.目标（target）

　　引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。

　　7.代理(proxy)

　　怎么实现整套aop机制的，都是通过代理，这个一会给细说。

　　8.织入(weaving)

　　把切面应用到目标对象来创建新的代理对象的过程。有3种方式，spring采用的是运行时，为什么是运行时，后面解释。

　　关键就是：切点定义了哪些连接点会得到通知

　　4.我所理解的aop原理

　　spring用代理类包裹切面，把他们织入到Spring管理的bean中。也就是说代理类伪装成目标类，它会截取对目标类中方法的调用，让调用者对目标类的调用都先变成调用伪装类，伪装类中就先执行了切面，再把调用转发给真正的目标bean。

　　现在可以自己想一想，怎么搞出来这个伪装类，才不会被调用者发现（过JVM的检查，JAVA是强类型检查，哪里都要检查类型）。

　　1.实现和目标类相同的接口，我也实现和你一样的接口，反正上层都是接口级别的调用，这样我就伪装成了和目标类一样的类（实现了同一接口，咱是兄弟了），也就逃过了类型检查，到java运行期的时候，利用多态的后期绑定（所以spring采用运行时），伪装类（代理类）就变成了接口的真正实现，而他里面包裹了真实的那个目标类，最后实现具体功能的还是目标类，只不过伪装类在之前干了点事情（写日志，安全检查，事物等）。

　　这就好比，一个人让你办件事，每次这个时候，你弟弟就会先出来，当然他分不出来了，以为是你，你这个弟弟虽然办不了这事，但是他知道你能办，所以就答应下来了，并且收了点礼物（写日志），收完礼物了，给把事给人家办了啊，所以你弟弟又找你这个哥哥来了，最后把这是办了的还是你自己。但是你自己并不知道你弟弟已经收礼物了，你只是专心把这件事情做好。

　　顺着这个思路想，要是本身这个类就没实现一个接口呢，你怎么伪装我，我就压根没有机会让你搞出这个双胞胎的弟弟，那么就用第2种代理方式，创建一个目标类的子类，生个儿子，让儿子伪装我

　　2.生成子类调用，这次用子类来做为伪装类，当然这样也能逃过JVM的强类型检查，我继承的吗，当然查不出来了，子类重写了目标类的所有方法，当然在这些重写的方法中，不仅实现了目标类的功能，还在这些功能之前，实现了一些其他的（写日志，安全检查，事物等）。

　　这次的对比就是，儿子先从爸爸那把本事都学会了，所有人都找儿子办事情，但是儿子每次办和爸爸同样的事之前，都要收点小礼物（写日志），然后才去办真正的事。当然爸爸是不知道儿子这么干的了。这里就有件事情要说，某些本事是爸爸独有的(final的)，儿子学不了，学不了就办不了这件事，办不了这个事情，自然就不能收人家礼了。

　　前一种兄弟模式，spring会使用JDK的java.lang.reflect.Proxy类，它允许Spring动态生成一个新类来实现必要的接口，织入通知，并且把对这些接口的任何调用都转发到目标类。

　　后一种父子模式，spring使用CGLIB库生成目标类的一个子类，在创建这个子类的时候，spring织入通知，并且把对这个子类的调用委托到目标类。

　　相比之下，还是兄弟模式好些，他能更好的实现松耦合，尤其在今天都高喊着面向接口编程的情况下，父子模式只是在没有实现接口的时候，也能织入通知，应当做一种例外。

切面（Aspect）：其实就是共有功能的实现。如日志切面、权限切面、事务切面等。在实际应用中通常是一个存放共有功能实现的普通Java类，之所以能被AOP容器识别成切面，是在配置中指定的。

通知（Advice）：是切面的具体实现。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际应用中通常是切面类中的一个方法，具体属于哪类通知，同样是在配置中指定的。

连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出或字段修改等，但Spring只支持方法级的连接点。

切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。

目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象。这些对象中已经只剩下干干净净的核心业务逻辑代码了，所有的共有功能代码等待AOP容器的切入。

代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象的核心业务逻辑功能加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。

织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译期、类装载期及运行期，当然不同的发生点有着不同的前提条件。譬如发生在编译期的话，就要求有一个支持这种AOP实现的特殊编译器；发生在类装载期，就要求有一个支持AOP实现的特殊类装载器；只有发生在运行期，则可直接通过Java语言的反射机制与动态代理机制来动态实现。

我想这可以帮助初学者理解AOP,当然,我也是初学者，说的不对的地方，欢迎拍砖 